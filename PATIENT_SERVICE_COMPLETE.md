# Patient Service Complete! ✅

## Overview
The Patient Service with UUID primary keys, RabbitMQ event publishing, and Redis caching has been successfully implemented.

## What Was Built

### Project Structure
```
patient-service/
├── pom.xml
├── src/main/
│   ├── java/com/hospital/patient/
│   │   ├── PatientServiceApplication.java
│   │   ├── entity/
│   │   │   └── Patient.java                  # UUID, Disease enum, no cascades
│   │   ├── repository/
│   │   │   └── PatientRepository.java       # JPA with custom queries
│   │   ├── service/
│   │   │   └── PatientService.java          # CRUD, caching, events
│   │   ├── controller/
│   │   │   └── PatientController.java       # REST API with Swagger
│   │   ├── dto/
│   │   │   ├── PatientDto.java
│   │   │   ├── CreatePatientRequest.java
│   │   │   └── UpdatePatientRequest.java
│   │   ├── event/
│   │   │   └── PatientEventPublisher.java   # RabbitMQ events
│   │   └── config/
│   │       ├── ModelMapperConfig.java
│   │       └── GlobalExceptionHandler.java
│   └── resources/
│       └── application.yml
```

## Key Features

### 1. UUID Primary Keys
- All patients have UUID as primary key
- `userId` field references User entity in Auth Service (no FK constraint)
- Generated by PostgreSQL: `@GeneratedValue(strategy = GenerationType.UUID)`

### 2. Patient Entity
```java
@Entity
@Table(name = "patients", schema = "patient_service")
public class Patient {
    private UUID id;                    // Primary key
    private UUID userId;                // Auth Service reference
    private String name;
    private String email;               // Unique
    private String phone;
    private Gender gender;              // Enum
    private LocalDate dateOfBirth;
    private String address;
    private Disease disease;            // Enum (24 types)
    private String medicalHistory;
    private String emergencyContact;
    private String emergencyPhone;
    private Boolean active;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    private String metadata;            // JSONB

    @Transient
    public int getAge();               // Calculated from DOB
}
```

### 3. Event-Driven Architecture
**Events Published to RabbitMQ:**
- `PatientCreatedEvent` - When patient is created
- `PatientUpdatedEvent` - When patient is updated
- `PatientDeletedEvent` - When patient is deleted

**Exchange:** `hospital.events.direct`
**Routing Keys:**
- `patient.created`
- `patient.updated`
- `patient.deleted`

These events will be consumed by:
- Appointment Service (for patient snapshots)
- Notification Service (for welcome emails)
- Audit Service (for compliance logging)

### 4. Redis Caching
- `@Cacheable` on `getPatientById()` - Cache reads
- `@CachePut` on `updatePatient()` - Update cache
- `@CacheEvict` on `deletePatient()` - Invalidate cache
- **Cache Name:** `patients`
- **TTL:** 1 hour (from config-repo/patient-service.yml)
- **Key:** Patient UUID

### 5. REST API Endpoints

#### Create Patient
```http
POST /api/patients
Content-Type: application/json

{
  "userId": "123e4567-e89b-12d3-a456-426614174000",
  "name": "John Doe",
  "email": "john@example.com",
  "phone": "+1234567890",
  "gender": "MALE",
  "dateOfBirth": "1990-01-15",
  "address": "123 Main St, City",
  "disease": "DIABETES",
  "medicalHistory": "Type 2 diabetes diagnosed in 2020",
  "emergencyContact": "Jane Doe",
  "emergencyPhone": "+1234567891"
}

Response 201 Created:
{
  "success": true,
  "message": "Patient created successfully",
  "data": {
    "id": "456e7890-e12b-34d5-a678-901234567890",
    "userId": "123e4567-e89b-12d3-a456-426614174000",
    "name": "John Doe",
    "email": "john@example.com",
    "age": 35,
    "disease": "DIABETES",
    ...
  }
}
```

#### Get Patient by ID (Cached)
```http
GET /api/patients/{id}

Response 200 OK:
{
  "success": true,
  "data": {
    "id": "456e7890-e12b-34d5-a678-901234567890",
    "userId": "123e4567-e89b-12d3-a456-426614174000",
    "name": "John Doe",
    "email": "john@example.com",
    "phone": "+1234567890",
    "gender": "MALE",
    "dateOfBirth": "1990-01-15",
    "age": 35,
    "address": "123 Main St, City",
    "disease": "DIABETES",
    "medicalHistory": "Type 2 diabetes diagnosed in 2020",
    "emergencyContact": "Jane Doe",
    "emergencyPhone": "+1234567891",
    "active": true,
    "createdAt": "2025-12-31T20:00:00",
    "updatedAt": "2025-12-31T20:00:00"
  }
}
```

#### Get All Patients (Paginated)
```http
GET /api/patients?page=0&size=10&sortBy=createdAt&direction=DESC

Response 200 OK:
{
  "content": [ /* array of patients */ ],
  "pageNumber": 0,
  "pageSize": 10,
  "totalElements": 50,
  "totalPages": 5,
  "last": false,
  "first": true
}
```

#### Search Patients
```http
GET /api/patients/search?query=john&page=0&size=10

Response: Paginated list of patients matching "john" in name or email
```

#### Get Patients by Disease
```http
GET /api/patients/disease/DIABETES

Response 200 OK:
{
  "success": true,
  "data": [
    { /* patient 1 */ },
    { /* patient 2 */ }
  ]
}
```

#### Count Patients by Disease
```http
GET /api/patients/disease/DIABETES/count

Response 200 OK:
{
  "success": true,
  "data": 15
}
```

#### Update Patient (Cache Updated)
```http
PUT /api/patients/{id}
Content-Type: application/json

{
  "phone": "+9876543210",
  "address": "456 New Address",
  "disease": "HYPERTENSION"
}

Response 200 OK:
{
  "success": true,
  "message": "Patient updated successfully",
  "data": { /* updated patient */ }
}
```

#### Delete Patient (Cache Evicted)
```http
DELETE /api/patients/{id}

Response 200 OK:
{
  "success": true,
  "message": "Patient deleted successfully",
  "data": null
}
```

#### Additional Endpoints
- `GET /api/patients/user/{userId}` - Get patient by user ID
- `GET /api/patients/email/{email}` - Get patient by email
- `GET /api/patients/active` - Get active patients (paginated)
- `GET /api/patients/health` - Health check

## Database Schema

```sql
CREATE TABLE patient_service.patients (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL UNIQUE,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(100) NOT NULL UNIQUE,
    phone VARCHAR(20),
    gender VARCHAR(10) NOT NULL,
    date_of_birth DATE NOT NULL,
    address VARCHAR(500),
    disease VARCHAR(50) NOT NULL,
    medical_history TEXT,
    emergency_contact VARCHAR(100),
    emergency_phone VARCHAR(20),
    active BOOLEAN NOT NULL DEFAULT TRUE,
    created_at TIMESTAMP NOT NULL,
    updated_at TIMESTAMP,
    metadata TEXT
);

CREATE INDEX idx_patients_user_id ON patient_service.patients(user_id);
CREATE INDEX idx_patients_email ON patient_service.patients(email);
CREATE INDEX idx_patients_disease ON patient_service.patients(disease);
```

## Configuration

From `config-repo/patient-service.yml`:
```yaml
server:
  port: 8082

spring:
  application:
    name: patient-service
  jpa:
    properties:
      hibernate:
        default_schema: patient_service
  cache:
    type: redis
    cache-names: patients
    redis:
      time-to-live: 3600000  # 1 hour
```

## Dependencies

- Spring Boot Web
- Spring Data JPA
- PostgreSQL Driver
- Spring Data Redis (caching)
- Spring AMQP (RabbitMQ)
- Spring Validation
- Eureka Client
- Config Client
- OpenFeign
- Hospital Common Library
- ModelMapper
- SpringDoc OpenAPI (Swagger)
- Lombok

## Event Flow Example

### Patient Created:
1. `POST /api/patients` → PatientService.createPatient()
2. Save patient to PostgreSQL
3. PatientEventPublisher.publishPatientCreated()
4. Event sent to RabbitMQ exchange `hospital.events.direct` with routing key `patient.created`
5. Appointment Service consumes event → updates patient snapshot
6. Notification Service consumes event → sends welcome email
7. Audit Service consumes event → logs creation

### Patient Updated:
1. `PUT /api/patients/{id}` → PatientService.updatePatient()
2. Update patient in PostgreSQL
3. Update Redis cache (via `@CachePut`)
4. PatientEventPublisher.publishPatientUpdated()
5. Event sent to RabbitMQ
6. Appointment Service updates snapshot
7. Cache invalidation event published

### Patient Deleted:
1. `DELETE /api/patients/{id}` → PatientService.deletePatient()
2. Delete patient from PostgreSQL
3. Evict from Redis cache (via `@CacheEvict`)
4. PatientEventPublisher.publishPatientDeleted()
5. Event sent to RabbitMQ
6. Appointment Service marks appointments as cancelled
7. Other services clean up related data

## No Cascade Relationships

Unlike the monolith, the Patient entity has **NO** cascade relationships:
```java
// REMOVED from Patient.java:
// @OneToMany(mappedBy = "patient", cascade = CascadeType.ALL)
// private List<Appointment> appointments;
//
// @OneToMany(mappedBy = "patient", cascade = CascadeType.ALL)
// private List<MedicalRecord> medicalRecords;
```

Instead:
- **Foreign keys removed** across schemas
- **Events used** for data synchronization
- **Application-level validation** via Feign clients
- **Snapshots maintained** in Appointment Service

## Validation

- Email uniqueness enforced
- UserId uniqueness enforced
- Jakarta Validation annotations on DTOs
- Custom business logic validation
- Structured error responses

## Testing

### Create a Patient
```bash
curl -X POST http://localhost:8082/api/patients \
  -H "Content-Type: application/json" \
  -d '{
    "userId": "123e4567-e89b-12d3-a456-426614174000",
    "name": "Test Patient",
    "email": "test@example.com",
    "phone": "+1234567890",
    "gender": "MALE",
    "dateOfBirth": "1990-01-15",
    "disease": "DIABETES",
    "address": "123 Test St"
  }'
```

### Get Patient (cached)
```bash
curl http://localhost:8082/api/patients/{id}
```

### Search Patients
```bash
curl "http://localhost:8082/api/patients/search?query=test"
```

### Check RabbitMQ Events
1. Open http://localhost:15672
2. Go to Queues tab
3. Verify `patient.updates` queue has messages

### Check Redis Cache
```bash
docker exec -it hospital-redis redis-cli
AUTH redis_password_2025
KEYS patients::*
GET patients::{uuid}
```

## Swagger Documentation

Access API documentation at:
```
http://localhost:8082/swagger-ui.html
```

## Integration Points

### With Auth Service:
- `userId` references User entity
- Validated via Feign client (future)

### With Appointment Service:
- Publishes events for snapshot updates
- Provides patient validation endpoint

### With Notification Service:
- PatientCreatedEvent triggers welcome email
- PatientUpdatedEvent triggers update notifications

### With Audit Service:
- All events logged for compliance
- HIPAA-compliant audit trail

## Files Created

- `patient-service/pom.xml`
- `PatientServiceApplication.java`
- `entity/Patient.java`
- `repository/PatientRepository.java`
- `service/PatientService.java`
- `controller/PatientController.java`
- `dto/PatientDto.java`, `CreatePatientRequest.java`, `UpdatePatientRequest.java`
- `event/PatientEventPublisher.java`
- `config/ModelMapperConfig.java`, `GlobalExceptionHandler.java`
- `resources/application.yml`

**Total: 12 Java classes + 1 config file = 13 files**

## Next Steps

✅ Patient Service Complete
⏭️ Build Doctor Service (similar structure)
⏭️ Build Appointment Service (with Feign clients and snapshots)

The Patient Service is ready to run alongside Auth Service!
